import math
import asyncio
import numpy as np
import matplotlib.pyplot as plt
import ipywidgets as widgets
import serial
import ikpy.chain
import ikpy.utils.plot as plot_utils

# Load Robot Arm Model
my_chain = ikpy.chain.Chain.from_urdf_file("arm_urdf.urdf", active_links_mask=[False, True, True, True, True, True, True])

# Set Initial Position and Orientation
target_position = [0, 0, 0.58]
target_orientation = [-1, 0, 0]

# Calculate Inverse Kinematics
ik = my_chain.inverse_kinematics(target_position, target_orientation, orientation_mode="Y")
print("The angles of each joints are:", list(map(lambda r: math.degrees(r), ik.tolist())))

# Forward Kinematics Check
computed_position = my_chain.forward_kinematics(ik)
print("Computed position:", computed_position[:3, 3], ", original position:", target_position)
print("Computed position (readable):", ['%.2f' % elem for elem in computed_position[:3, 3]])

# Visualize the Robot Arm
fig, ax = plot_utils.init_3d_figure()
fig.set_figheight(9)
fig.set_figwidth(13)
my_chain.plot(ik, ax, target=target_position)
plt.xlim(-0.5, 0.5)
plt.ylim(-0.5, 0.5)
ax.set_zlim(0, 0.6)
plt.ion()

# Define Functions for Movement
def doIK():
    global ik
    old_position = ik.copy()
    ik = my_chain.inverse_kinematics(target_position, target_orientation, orientation_mode="Z", initial_position=old_position)

def updatePlot():
    ax.clear()
    my_chain.plot(ik, ax, target=target_position)
    plt.xlim(-0.5, 0.5)
    plt.ylim(-0.5, 0.5)
    ax.set_zlim(0, 0.6)
    fig.canvas.draw()
    fig.canvas.flush_events()

def move(x, y, z):
    global target_position
    target_position = [x, y, z]
    doIK()
    updatePlot()
    # sendCommand(ik[1].item(), ik[2].item(), ik[3].item(), ik[4].item(), ik[5].item(), ik[6].item(), 1)

# Move the Robot Arm
move(0.6, 0.4, 0.3)

# Controller Integration
con = widgets.Controller()
display(con)

# Background Task for Controller Monitoring
async def main():
    x = 0
    y = 0.25
    z = 0.1
    while con.buttons[9].value < 1:
        xp = con.axes[0].value
        yp = con.axes[1].value
        zp = con.axes[2].value
        if abs(xp) > 0.1 or abs(yp) > 0.1 or abs(zp) > 0.1:
            x += xp / 100
            y -= yp / 100
            z -= zp / 100
            move(x, y, z)
        await asyncio.sleep(0.05)

loop = asyncio.get_event_loop()
loop.create_task(main())

# Closing Serial Port
# ser.close()
